from typing import List, Dict, Any
import re

def detect_hardcoded_secrets(code: str) -> List[Dict[str, Any]]:
    patterns = [
        r"api_key\s*=\s*['\"]\w{8,}['\"]",
        r"AKIA[0-9A-Z]{16}",
        r"ghp_[A-Za-z0-9]{36}"
    ]
    issues = []
    for pat in patterns:
        for m in re.finditer(pat, code):
            issues.append({
                "type": "hardcoded_secret",
                "pattern": pat,
                "match": m.group(0),
                "start": m.start(),
                "end": m.end(),
                "cwe": "CWE-798",
                "owasp": "A02:2021"
            })
    return issues

def detect_sql_injection(code: str) -> List[Dict[str, Any]]:
    patterns = [
        r"execute\s*\(.*\+.*\)",
    ]
    issues = []
    for pat in patterns:
        for m in re.finditer(pat, code, re.IGNORECASE):
            issues.append({
                "type": "sql_injection_risk",
                "pattern": pat,
                "match": m.group(0),
                "start": m.start(),
                "end": m.end(),
                "cwe": "CWE-89",
                "owasp": "A03:2021"
            })
    return issues

def detect_insecure_deserialization(code: str) -> List[Dict[str, Any]]:
    patterns = [
        r"pickle\.loads\(",
        r"eval\(",
        r"yaml\.load\(",
    ]
    issues = []
    for pat in patterns:
        for m in re.finditer(pat, code):
            issues.append({
                "type": "insecure_deserialization",
                "pattern": pat,
                "match": m.group(0),
                "start": m.start(),
                "end": m.end(),
                "cwe": "CWE-502",
                "owasp": "A08:2021"
            })
    return issues

def detect_unsafe_exec(code: str) -> List[Dict[str, Any]]:
    patterns = [
        r"os\.system\(",
        r"subprocess\.Popen\(",
        r"exec\(",
    ]
    issues = []
    for pat in patterns:
        for m in re.finditer(pat, code):
            issues.append({
                "type": "unsafe_execution",
                "pattern": pat,
                "match": m.group(0),
                "start": m.start(),
                "end": m.end(),
                "cwe": "CWE-78",
                "owasp": "A01:2021"
            })
    return issues

def detect_copilot_generated_code_segments(code: str) -> List[Dict[str, Any]]:
    copilot_patterns = [
        r"(?i)generated by copilot",
        r"(?i)copilot suggestion",
        r"(?i)copyright github copilot",
        r"(?i)AI-generated code",
        r"(?i)Created with Copilot",
    ]
    segments = []
    for pat in copilot_patterns:
        for m in re.finditer(pat, code):
            segments.append({
                "start": m.start(),
                "end": m.end(),
                "pattern": pat,
                "match": m.group(0)
            })
    return segments

def run_security_rules(code: str) -> List[Dict[str, Any]]:
    issues = []
    copilot_segments = detect_copilot_generated_code_segments(code)
    is_copilot = bool(copilot_segments)
    issues.extend(detect_hardcoded_secrets(code))
    issues.extend(detect_sql_injection(code))
    issues.extend(detect_insecure_deserialization(code))
    issues.extend(detect_unsafe_exec(code))
    issues.extend([
        {
            "type": "copilot_generated_code",
            "pattern": seg["pattern"],
            "match": seg["match"],
            "start": seg["start"],
            "end": seg["end"],
            "note": "Likely Copilot-generated code segment"
        } for seg in copilot_segments
    ])
    if is_copilot:
        for issue in issues:
            issue["copilot_strict"] = True
    return issues
    if is_copilot:
        for issue in issues:
            issue["copilot_strict"] = True
    return issues
