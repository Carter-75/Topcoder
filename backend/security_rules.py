import re
from typing import List, Dict, Any

# --- Security Rule Implementations ---

def detect_hardcoded_secrets(code: str) -> List[Dict[str, Any]]:
    # Simple regex for API keys, tokens, passwords (MVP, not exhaustive)
    patterns = [
        r"(?i)(api[_-]?key|secret|token|password)["']?\s*[:=]\s*["'][^"']{8,}["']",
        r"AKIA[0-9A-Z]{16}",  # AWS key stub
        r"ghp_[A-Za-z0-9]{36}",  # GitHub token stub
    ]
    issues = []
    for pat in patterns:
        for m in re.finditer(pat, code):
            issues.append({
                "type": "hardcoded_secret",
                "pattern": pat,
                "match": m.group(0),
                "start": m.start(),
                "end": m.end(),
                "cwe": "CWE-798",
                "owasp": "A02:2021"
            })
    return issues

def detect_sql_injection(code: str) -> List[Dict[str, Any]]:
    # Look for string concatenation in SQL queries (MVP)
    patterns = [
        r"execute\s*\(.*[+].*\)",
        r"SELECT.*['\"]\s*\+",
    ]
    issues = []
    for pat in patterns:
        for m in re.finditer(pat, code, re.IGNORECASE):
            issues.append({
                "type": "sql_injection_risk",
                "pattern": pat,
                "match": m.group(0),
                "start": m.start(),
                "end": m.end(),
                "cwe": "CWE-89",
                "owasp": "A03:2021"
            })
    return issues

def detect_insecure_deserialization(code: str) -> List[Dict[str, Any]]:
    # Look for use of pickle.loads, eval, etc. (MVP)
    patterns = [
        r"pickle\.loads\(",
        r"eval\(",
        r"yaml\.load\(",
    ]
    issues = []
    for pat in patterns:
        for m in re.finditer(pat, code):
            issues.append({
                "type": "insecure_deserialization",
                "pattern": pat,
                "match": m.group(0),
                "start": m.start(),
                "end": m.end(),
                "cwe": "CWE-502",
                "owasp": "A08:2021"
            })
    return issues

def detect_unsafe_exec(code: str) -> List[Dict[str, Any]]:
    # Look for os.system, subprocess, exec, etc. (MVP)
    patterns = [
        r"os\.system\(",
        r"subprocess\.Popen\(",
        r"exec\(",
    ]
    issues = []
    for pat in patterns:
        for m in re.finditer(pat, code):
            issues.append({
                "type": "unsafe_execution",
                "pattern": pat,
                "match": m.group(0),
                "start": m.start(),
                "end": m.end(),
                "cwe": "CWE-78",
                "owasp": "A01:2021"
            })
    return issues

def detect_copilot_generated_code_segments(code: str) -> List[Dict[str, Any]]:
    # Heuristic: Find Copilot signature comments or known patterns
    copilot_patterns = [
        r"(?i)generated by copilot",
        r"(?i)copilot suggestion",
        r"(?i)copyright github copilot",
        r"(?i)AI-generated code",
        r"(?i)Created with Copilot",
    ]
    segments = []
    for pat in copilot_patterns:
        for m in re.finditer(pat, code):
            segments.append({
                "start": m.start(),
                "end": m.end(),
                "pattern": pat,
                "match": m.group(0)
            })
    return segments

def run_security_rules(code: str) -> List[Dict[str, Any]]:
    issues = []
    copilot_segments = detect_copilot_generated_code_segments(code)
    # If Copilot code detected, apply stricter policy to all issues
    is_copilot = bool(copilot_segments)
    issues.extend(detect_hardcoded_secrets(code))
    issues.extend(detect_sql_injection(code))
    issues.extend(detect_insecure_deserialization(code))
    issues.extend(detect_unsafe_exec(code))
    issues.extend([
        {
            "type": "copilot_generated_code",
            "pattern": seg["pattern"],
            "match": seg["match"],
            "start": seg["start"],
            "end": seg["end"],
            "note": "Likely Copilot-generated code segment"
        } for seg in copilot_segments
    ])
    # Mark all issues as 'copilot_strict' if Copilot code present
    if is_copilot:
        for issue in issues:
            issue["copilot_strict"] = True
    return issues
